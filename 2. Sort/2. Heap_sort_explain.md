## Heap sort

힙정렬은 평균, 최악의 경우 시간복잡도는 O(n logn) 이다.

buildHeap 을 수행할 때 O(n), 나머지 n개의 원소에 대해 heapify 를 수행할 때 O(n *logn) 이다.

> 힙정렬을 사용하기 위해서는 완전이진트리이면서, 최소힙 혹은 최대힙을 만족해야 한다.
  
  
1. buildHeap?  
buildHeap 이란, 정렬해야하는 원소들이 들어있는 배열을 힙정렬이 가능한 조건으로 만족시키기 위해 최소힙, 최대힙으로 변환하는 선 작업이다.  
(다시말해, buildHeap은 heapify가 가능하도록 배열 원소들을 재배치하는 작업이다.)

2. heapify?  
heapify 란, 완전이진트리를 최소힙 혹은 최대힙으로 변환시켜주는 작업을 한다.

3. 최소힙? 최대힙?  
최소힙 혹은 최대힙이란, 이진트리에서 부모의 노드가 자식노드의 값보다 무조건 더 작거나(최소힙 만족), 더 큰 성질(최대힙)을 만족하는 상태이다.  
  
<br>
힙정렬을 풀어서 설명하면, 

1. 완전이진트리이면서 최소힙일 경우 
2. 최상위 루트 노드는 모든 노드중에서 제일 작은 값이 되므로 해당 값을 전체 노드의 제일 마지막 리프노드(오른쪽 끝) 와 변경시키고 (n은 → n-1개가 됨)
3. 다시 최소힙 성질을 만족하는 상태로 변경 (heapify) 하는 작업을 거친다. (끝나면 위 2번과 3번을 재귀적으로 반복)

즉, buildHeap, heapify 작업을 통해 heap sort 를 진행하면 결국 정렬이 된다.
<br>

### BuildHeap 이 O(n) 인 이유

---

buildHeap 은 전체 원소 n 개 중에 가장 마지막 리프노드들을 제외한 노드들만 진행한다.

가장 마지막 리프노드들은 최소힙, 최대힙을 이미 만족하기 때문에 진행 할 필요가 없다.

(buildHeap 은 자신의 자식 노드의 값과 크기를 비교하여 자리를 바꿔주는 작업이기때문에 가장 마지막 리프노드들은 자식노드가 없으므로 비교할 자식이 없다.)

buildHeap 은 n/2 번에 대해서 반복문을 돌지만 결국 O(n) 을 만족하기 때문에 O(n) 이다.

### Heapify 가 O(logn) 인 이유 - (주의. 한번의 heapify에 대해서만 O(logn) 이다.)

---

heapify 는 전체 노드 n 개의 반인 n/2 개의 원소에 대해서만 작업을 진행하기 때문에 O(logn) 이다. 

(전체 원소 n 을 이진트리로 바꿀 경우 트리의 높이는 n/2 가 되고 n/2 개의 원소에 대한 재귀 작업은 O(logn) 이게 된다)

하지만, 결국 heapify() n번 진행하게 되므로 O(n * logn) 이 되고 buildHeap 의 시간복잡도와 더해

O(n) + O(n * logn) = O(n logn) 이 된다.
